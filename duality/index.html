<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Duality</title>

<style>
  /* Top bar container */
  .top-bar {
    width: 100%;
    height: 60px; /* adjust height as needed */
    background-color: #333; /* dark background */
    display: flex;
    align-items: center;
    padding: 0 20px; /* horizontal padding */
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    position: fixed; /* stays at the top */
    top: 0;
    left: 0;
    z-index: 1000;
  }

  /* Logo image */
  .top-bar img {
    height: 40px; /* logo height */
    cursor: pointer;
    transition: transform 0.2s;
  }

  .top-bar img:hover {
    transform: scale(1.1); /* subtle hover effect */
  }

  /* Optional: content next to logo */
  .top-bar .title {
    color: white;
    font-size: 20px;
    font-weight: bold;
    margin-left: 15px;
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    
    margin: 0;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    position: relative;

    background: radial-gradient(1200px 800px at 10% 20%, rgba(30,40,60,0.28), transparent),
                  radial-gradient(900px 600px at 90% 80%, rgba(90,60,140,0.08), transparent),
                  var(--bg);
    color:var(--text);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  h2 {
    margin-bottom: 16px;
    color: #333;
    position: absolute;
    top: 20px;
    width: 100%;
    text-align: center;
  }

  #container {
  position: absolute;
  top: 400px;
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(4, 1fr);
  gap: 10px;
}

#bob {
  position: absolute;
  top: 25%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10;
  /* width: 500px; or desired size */
  height: auto;
  border-radius: 12px;
  transition: opacity 0.2s;
}

#bob2 {
  position: absolute;
  top: 25%;
  left: 30%;
  transform: translate(-50%, -50%);
  z-index: 10;
  /* width: 500px; or desired size */
  height: auto;
  border-radius: 12px;
  transition: opacity 0.2s;
}

#bob3 {
  position: absolute;
  top: 25%;
  left: 70%;
  transform: translate(-50%, -50%);
  z-index: 10;
  /* width: 500px; or desired size */
  height: auto;
  border-radius: 12px;
  transition: opacity 0.2s;
}

#imageList {
  display: contents; /* allows children to occupy grid cells */
}

#imageList button {
  width: 100%;
  height: 100%;
  flex: unset;
}

/* full-bleed canvas */
    #stage {
      display:block;
      width:100%;
      height:100vh;
      touch-action:none;
    }

  #imageList button:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    z-index: 2;
  }

  #imageList img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 12px;
    display: block;
    transition: opacity 0.2s;
  }

  #imageList img:hover {
    opacity: 0.95;
  }

  #imageList button::after {
    content: attr(data-title);
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    padding: 6px 10px;
    background: rgba(0, 0, 0, 0.5);
    color: #fff;
    font-size: 14px;
    opacity: 0;
    transition: opacity 0.2s;
    border-bottom-left-radius: 12px;
    border-bottom-right-radius: 12px;
  }

  #imageList button:hover::after {
    opacity: 1;
  }

  .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .modal {
        background: white;
        padding: 30px 40px;
        border-radius: 10px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        width: 350px;
        max-width: 90%;
        text-align: center;
        position: relative;
    }

    .modal h2 {
        margin-bottom: 20px;
        color: #333;
    }

    .modal input[type="text"],
    .modal input[type="password"] {
        width: 100%;
        padding: 12px 15px;
        margin: 10px 0;
        border: 1px solid #ccc;
        border-radius: 6px;
        font-size: 16px;
    }

    .modal button[type="submit"] {
        width: 100%;
        padding: 12px;
        background-color: #4CAF50;
        border: none;
        color: white;
        font-size: 16px;
        border-radius: 6px;
        cursor: pointer;
        margin-top: 15px;
        transition: background 0.3s;
    }

    .modal button[type="submit"]:hover {
        background-color: #45a049;
    }

    .overlay.active {
        display: flex;
    }

</style>
<link rel="icon" href="/img/favicon.ico">
</head>
<body>

  <canvas id="stage"></canvas>

  <script>
  // Molecule Particle System (single-file, vanilla JS)
  (function(){
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: true });

    // device pixel ratio for crisp rendering
    let DPR = Math.min(window.devicePixelRatio || 1, 2);

    // state
    let w = 0, h = 0;
    let particles = [];
    let running = true;

    // mouse / touch
    const pointer = { x: null, y: null, down: false };

    // parameters (derived from UI)
    const params = {
      count: 50,
      size: 2,
      speed: 2,
      color: "rgb(1, 1, 1)",
      linkRange: 100,
      mode: "Repel",
    };

    // helpers
    function rand(mn, mx){ return Math.random() * (mx - mn) + mn; }
    function map(v, a, b, c, d){ return c + (v - a) * (d - c) / (b - a); }

    // resize canvas
    function resize(){
      DPR = Math.min(window.devicePixelRatio || 1, 2);
      w = Math.max(300, Math.floor(window.innerWidth));
      h = Math.max(300, Math.floor(window.innerHeight));
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }

    // particle class
    class Particle {
      constructor(x, y){
        this.x = x ?? rand(0, w);
        this.y = y ?? rand(0, h);
        const s = params.size;
        this.r = rand(s * 0.6, s * 1.4);
        this.vx = rand(-0.5, 0.5);
        this.vy = rand(-0.5, 0.5);
        this.mass = this.r * 0.4;
        this.hueShift = rand(-30, 30);
        this.age = 0;
      }
      step(dt){
        // simple Brownian / velocity
        const speed = 0.3 + params.speed * 0.9;
        this.vx += rand(-0.08, 0.08) * speed * 0.5;
        this.vy += rand(-0.08, 0.08) * speed * 0.5;

        // clamp velocity
        const vlim = 2.4 + params.speed * 4.0;
        this.vx = Math.max(-vlim, Math.min(vlim, this.vx));
        this.vy = Math.max(-vlim, Math.min(vlim, this.vy));

        // apply pointer interactions
        if (pointer.x !== null && pointer.y !== null) {
          const dx = pointer.x - this.x;
          const dy = pointer.y - this.y;
          const d2 = dx*dx + dy*dy;
          const d = Math.sqrt(d2) + 0.0001;

          // only influence within a radius
          const influenceRadius = Math.max(80, params.linkRange * 0.8);
          if (d < influenceRadius) {
            const fall = 1 - (d / influenceRadius);
            const force = (params.mode === 'repel' ? -1 : 1) * fall * 0.6 * params.speed;
            this.vx += (dx / d) * force;
            this.vy += (dy / d) * force;

            // slight pull when pointer is down (spawn cluster 'stickiness')
            if (pointer.down) {
              this.vx *= 0.98;
              this.vy *= 0.98;
            }
          }
        }

        // friction / drag
        this.vx *= 0.995;
        this.vy *= 0.995;

        // integrate
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // wrap edges gently
        if (this.x < -20) this.x = w + 20;
        if (this.x > w + 20) this.x = -20;
        if (this.y < -20) this.y = h + 20;
        if (this.y > h + 20) this.y = -20;

        this.age += dt;
      }
      draw(ctx){
        const baseColor = params.color;
        // particle glow
        ctx.beginPath();
        ctx.fillStyle = hexToRGBA(baseColor, 0.12);
        ctx.arc(this.x, this.y, this.r * 6.0, 0, Math.PI*2);
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = hexToRGBA(baseColor, 0.22);
        ctx.arc(this.x, this.y, this.r * 3.0, 0, Math.PI*2);
        ctx.fill();

        // core
        ctx.beginPath();
        ctx.fillStyle = hexToRGBA(baseColor, 1.0);
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // color helpers
    function hexToRGBA(hex, alpha=1){
      // support formats: #RRGGBB or #RGB
      if (!hex) return `rgba(110,231,183,${alpha})`;
      const h = hex.replace('#','');
      let r,g,b;
      if (h.length === 3){
        r = parseInt(h[0]+h[0],16);
        g = parseInt(h[1]+h[1],16);
        b = parseInt(h[2]+h[2],16);
      } else {
        r = parseInt(h.slice(0,2),16);
        g = parseInt(h.slice(2,4),16);
        b = parseInt(h.slice(4,6),16);
      }
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // build particle array
    function buildParticles(n){
      particles.length = 0;
      for (let i=0;i<n;i++){
        particles.push(new Particle());
      }
    }

    // draw bonds (lines) between nearby particles
    function drawLinks(ctx){
      const linkMax = params.linkRange;
      const len = particles.length;
      for (let i=0;i<len;i++){
        const A = particles[i];
        for (let j=i+1;j<len;j++){
          const B = particles[j];
          const dx = A.x - B.x;
          const dy = A.y - B.y;
          const d2 = dx*dx + dy*dy;
          if (d2 > linkMax * linkMax) continue;
          const d = Math.sqrt(d2);
          const t = 1 - (d / linkMax);
          // bonding force (mild)
          const bond = t * 0.0008 * params.speed;
          A.vx += (dx / d) * bond * -1;
          A.vy += (dy / d) * bond * -1;
          B.vx += (dx / d) * bond;
          B.vy += (dy / d) * bond;

          // draw line
          ctx.beginPath();
          ctx.moveTo(A.x, A.y);
          ctx.lineTo(B.x, B.y);
          ctx.lineWidth = Math.max(0.3, t * 1.6);
          ctx.strokeStyle = hexToRGBA(params.color, Math.max(0.05, t * 0.45));
          ctx.stroke();
        }
      }
    }

    // animation loop
    let last = performance.now();
    function loop(t){
      if (!running) {
        last = t;
        requestAnimationFrame(loop);
        return;
      }
      const dtRaw = (t - last) / (1000/60); // normalize to 60fps base
      const dt = Math.min(3, dtRaw); // clamp big deltas
      last = t;

      // clear with small alpha to make subtle trails
      ctx.clearRect(0,0,w,h);
      ctx.globalCompositeOperation = 'lighter';

      // subtle vignette background
      ctx.fillStyle = 'rgba(6,8,16,0.16)';
      ctx.fillRect(0,0,w,h);

      // links
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      drawLinks(ctx);
      ctx.restore();

      // particles
      for (let i=0;i<particles.length;i++){
        particles[i].step(dt);
      }
      for (let i=0;i<particles.length;i++){
        particles[i].draw(ctx);
      }

      // pointer indicator
      if (pointer.x !== null && pointer.y !== null){
        ctx.beginPath();
        ctx.arc(pointer.x, pointer.y, 8, 0, Math.PI*2);
        ctx.fillStyle = hexToRGBA(params.color, 0.08);
        ctx.fill();
      }

      requestAnimationFrame(loop);
    }

    // events
    function onPointerMove(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX || (e.touches && e.touches[0].clientX) || 0) - rect.left;
      const y = (e.clientY || (e.touches && e.touches[0].clientY) || 0) - rect.top;
      pointer.x = x;
      pointer.y = y;
    }
    function onPointerDown(e){
      pointer.down = true;
      onPointerMove(e);
      spawnCluster(pointer.x, pointer.y, 6);
    }
    function onPointerUp(){
      pointer.down = false;
    }
    function onLeave(){
      // don't null out on leave on mobile; keep for desktop
      pointer.x = null;
      pointer.y = null;
    }

    // spawn a small cluster of particles at x,y
    function spawnCluster(x,y, n=8){
      for (let i=0;i<n;i++){
        const p = new Particle(x + rand(-16,16), y + rand(-16,16));
        p.vx += rand(-1.6,1.6);
        p.vy += rand(-1.6,1.6);
        particles.push(p);
      }
      // clamp to max preferred
      capParticles();
    }

    // keep particle list sensible
    function capParticles(){
      const max = Math.max(20, parseInt(50));
      const desired = 50;
      if (particles.length > desired){
        particles.splice(0, particles.length - desired);
      }
    }

    // // keyboard: space to pause
    // window.addEventListener('keydown', (e) => {
    //   if (e.code === 'Space') {
    //     e.preventDefault();
    //     running = !running;
    //   }
    //   // quick shortcuts
    //   if (e.key === 'r') ui.randomize.click();
    //   if (e.key === 'c') ui.color.focus();
    // });

    // pointer events
    canvas.addEventListener('mousemove', onPointerMove);
    canvas.addEventListener('touchmove', onPointerMove, { passive:true });
    canvas.addEventListener('mousedown', onPointerDown);
    canvas.addEventListener('touchstart', onPointerDown, { passive:true });
    window.addEventListener('mouseup', onPointerUp);
    window.addEventListener('touchend', onPointerUp);
    canvas.addEventListener('mouseleave', onLeave);

    // handle visibility change to stop ticks
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) running = false;
      else running = true;
    });

    // initialization
    function init(){
      resize();
      buildParticles(params.count);
      last = performance.now();
      requestAnimationFrame(loop);
    }

    // listen for resize
    window.addEventListener('resize', () => {
      resize();
    });

    // small performance guard: if many particles, reduce glow draws
    // but keep visual style.

    // expose some debug for console
    window.__molecule = {
      particles,
      params,
      spawn: spawnCluster,
    };

    // start
    init();

  })();
  </script>

  <div class="top-bar">
    <!-- Clickable logo -->
    <a href="https://10tothe6.github.io/duality">
      <img src="https://github.com/10tothe6/10tothe6.github.io/blob/main/img/duality_logo.png?raw=true" alt="Home Logo">
    </a>

  <!-- SIGNUP -->
  <!-- <form id="signup-form">
    <input id="signup-email" type="email" placeholder="Email">
    <input id="signup-password" type="password" placeholder="Password">
    <button>Sign Up</button>
  </form> -->

  <!-- LOGIN -->
  <!-- <form id="login-form">
    <input id="login-email" type="email" placeholder="Email">
    <input id="login-password" type="password" placeholder="Password">
    <button>Log In</button>
  </form> -->

  <button id="logout-btn" style="display:none">Log Out</button>

  <h3 id="status">Not logged in</h3>
  <button id = 'login-button'>Log In</button>
  <button id = 'signup-button'>Sign Up</button>
  </div>

  <div id="bob">
      <img id="carousel-image" width="550" src="https://github.com/10tothe6/10tothe6.github.io/blob/main/img/duality_logo.png?raw=true" alt="Example Image">
   </div>

   <img id="bob2" width="100" src="https://github.com/10tothe6/10tothe6.github.io/blob/main/img/logo_1.png?raw=true" alt="Example Image">
      <img id="bob3" width="100" src="https://github.com/10tothe6/10tothe6.github.io/blob/main/img/logo_1.png?raw=true" alt="Example Image">

   <script>
    // List of images
    const images = [
        "https://github.com/10tothe6/10tothe6.github.io/blob/main/img/duality_logo.png?raw=true",
        "https://github.com/10tothe6/10tothe6.github.io/blob/main/img/duality_logo_2.png?raw=true",
        "https://github.com/10tothe6/10tothe6.github.io/blob/main/img/duality_logo_3.png?raw=true",
        "https://github.com/10tothe6/10tothe6.github.io/blob/main/img/duality_logo_4.png?raw=true"
    ];

    let currentIndex = 0;
    let realIndex = 0;
    const carouselImage = document.getElementById('carousel-image');

    function showNextImage() {
      if (realIndex != 0) {
        realIndex = 0;
      } else {
        currentIndex = (currentIndex + 1) % images.length; // cycle through images
        realIndex = currentIndex;
      }
      
      carouselImage.src = images[realIndex];
    }

    // Change image every 3 seconds
    setInterval(showNextImage, 1000);
</script>

  <!-- <h2>Available Articles</h2> -->
  <div id="container">
    <div id="imageList">Loadingâ€¦</div>
  </div>

  <script>
    const bob = document.getElementById('bob');
    const bob2 = document.getElementById('bob2');
    const bob3 = document.getElementById('bob3');
    let pos1 = 0;
    let pos2 = 10;
    let pos3 = 15;
    let direction1 = 1; // 1 = up, -1 = down
    let direction2 = 1; 
    let direction3 = 1; 

    const speed = 0.1; // pixels per frame

    function animate() {
      pos1 += direction1 * speed;
      pos2 += direction2 * speed;
      pos3 += direction3 * speed;

      if (pos1 > 20) direction1 = -1;
      if (pos1 < 0) direction1 = 1;
      if (pos2 > 30) direction2 = -1;
      if (pos2 < 5) direction2 = 1;
      if (pos3 > 40) direction3 = -1;
      if (pos3 < -10) direction3 = 1;

      bob.style.transform = `translate(-50%, calc(-50% - ${pos1}px))`;
      bob2.style.transform = `translate(-50%, calc(-50% - ${pos2}px))`;
      bob3.style.transform = `translate(-50%, calc(-50% - ${pos3}px))`;
      requestAnimationFrame(animate);
    }

    animate();
  </script>

  <!-- Modal overlay -->
  <div class="overlay" id="modalOverlay">
      <div class="modal">
          <!-- <span class="close-btn" id="closeModalBtn">&times;</span> -->
          <h2>Sign In</h2>
          <!-- Form starts here -->
          <form id="signInForm" action="/login" method="POST">
              <input type="text" name="username" placeholder="Username" required>
              <input type="password" name="password" placeholder="Password" required>
              <button type="submit">Sign In</button>
          </form>
      </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
    import { getFirestore, collection, getDocs } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";
    import {
    getAuth,
    createUserWithEmailAndPassword,
    signInWithEmailAndPassword,
    signOut,
    onAuthStateChanged
  } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyArv-BB3H5pIZFZBANfFYFG1bBNxO0veeA",
      authDomain: "duality-articles.firebaseapp.com",
      projectId: "duality-articles",
      storageBucket: "duality-articles.firebasestorage.app",
      messagingSenderId: "497426954182",
      appId: "1:497426954182:web:8081f58e64d32048c3a4c7",
      measurementId: "G-TJ5TXZEQH5"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const imageListDiv = document.getElementById("imageList");

  const auth = getAuth(app);

  const lButton = document.getElementById("login-button");
  const sButton = document.getElementById("signup-button");

    const overlay = document.getElementById('modalOverlay');
    const form = document.getElementById('signInForm');

  lButton.addEventListener('click', () => {
        alert("login");
        overlay.classList.add('active');
    });

    sButton.addEventListener('click', () => {
        alert("signup");
    });

    // // DOM
    // const statusText = document.getElementById("status");
    // const logoutBtn = document.getElementById("logout-btn");

    // //
    // // 3. SIGN UP
    // //
    // document.getElementById("signup-form").addEventListener("submit", (e) => {
    //   e.preventDefault();

    //   const email = document.getElementById("signup-email").value;
    //   const password = document.getElementById("signup-password").value;

    //   createUserWithEmailAndPassword(auth, email, password)
    //     .then((cred) => {
    //       console.log("User created:", cred.user.email);
    //     })
    //     .catch((err) => {
    //       alert(err.message);
    //     });
    // });

    // //
    // // 4. LOG IN
    // //
    // document.getElementById("login-form").addEventListener("submit", (e) => {
    //   e.preventDefault();

    //   const email = document.getElementById("login-email").value;
    //   const password = document.getElementById("login-password").value;

    //   signInWithEmailAndPassword(auth, email, password)
    //     .then((cred) => {
    //       console.log("Logged in:", cred.user.email);
    //     })
    //     .catch((err) => {
    //       alert(err.message);
    //     });
    // });

    // //
    // // 5. LOG OUT
    // //
    // logoutBtn.addEventListener("click", () => {
    //   auth.signOut();
    // });

    // //
    // // 6. a state changes
    // //
    // onAuthStateChanged(auth, (user) => {
    //   if (user) {
    //     statusText.textContent = "Logged in as: " + user.email;
    //     logoutBtn.style.display = "block";
    //   } else {
    //     statusText.textContent = "Not logged in";
    //     logoutBtn.style.display = "none";
    //   }
    // });

    async function loadImages() {
      try {
        const snapshot = await getDocs(collection(db, "thumbnails"));
        imageListDiv.innerHTML = "";

        snapshot.forEach(doc => {
          const data = doc.data();
          const button = document.createElement("button");
          button.setAttribute("data-title", data.title);
          const img = document.createElement("img");
          img.src = data.url;
          button.appendChild(img);
          button.addEventListener("click", () => {
            window.location.href = "https://10tothe6.github.io/duality/articles/" + data.domain;
          });
          imageListDiv.appendChild(button);
        });
      } catch (err) {
        imageListDiv.innerHTML = "Error loading images.";
        console.error(err);
      }
    }

    loadImages();
  </script>
</body>
</html>