<script type="module">
  // Firebase v10+ modular SDK
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.15.0/firebase-app.js";
  import {
    getAuth,
    createUserWithEmailAndPassword,
    signInWithEmailAndPassword,
    signOut,
    onAuthStateChanged
  } from "https://www.gstatic.com/firebasejs/10.15.0/firebase-auth.js";

  // Your Firebase config
  const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
    projectId: "YOUR_PROJECT_ID",
    appId: "YOUR_APP_ID"
  };

  // Initialize
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);

  // --- SIGN UP ---
  window.signup = function () {
    const email = document.getElementById("signup-email").value;
    const password = document.getElementById("signup-password").value;

    createUserWithEmailAndPassword(auth, email, password)
      .then((cred) => {
        alert("Account created: " + cred.user.email);
      })
      .catch((err) => alert(err.message));
  };

  // --- LOGIN ---
  window.login = function () {
    const email = document.getElementById("login-email").value;
    const password = document.getElementById("login-password").value;

    signInWithEmailAndPassword(auth, email, password)
      .then((cred) => {
        alert("Logged in: " + cred.user.email);
      })
      .catch((err) => alert(err.message));
  };

  // --- LOGOUT ---
  window.logout = function () {
    signOut(auth);
  };

  // --- AUTH STATE ---
  onAuthStateChanged(auth, (user) => {
    if (user) {
      document.getElementById("status").innerText = "Logged in as: " + user.email;
      document.getElementById("logout-btn").style.display = "block";
    } else {
      document.getElementById("status").innerText = "Not logged in";
      document.getElementById("logout-btn").style.display = "none";
    }
  });
</script>
‚úÖ 3. Minimal HTML UI
Put this inside your <body>:

html
Copy code
<h2>Sign Up</h2>
<input id="signup-email" type="email" placeholder="Email">
<input id="signup-password" type="password" placeholder="Password">
<button onclick="signup()">Sign Up</button>

<h2>Log In</h2>
<input id="login-email" type="email" placeholder="Email">
<input id="login-password" type="password" placeholder="Password">
<button onclick="login()">Log In</button>

<button id="logout-btn" onclick="logout()" style="display:none;">Log Out</button>

<h3 id="status">Not logged in</h3>
üéâ That is the simplest possible Firebase Auth setup.
It gives you:

‚úî Create accounts

‚úî Log in

‚úî Log out

‚úî Live user session tracking

Want to add more?
I can help you add:

üîí Protected pages (redirect if not logged in)
üßë Google Sign-In button
üìÅ Store user profiles in Firestore
üì® Email verification
üîë Password reset

Just tell me what you want!







You said:
write me a webpage with a cool, molecule-style particle effect


ChatGPT said:

Thought for 4 seconds
Nice ‚Äî here‚Äôs a single-file webpage that renders a molecule-style particle effect: particles move, connect with lines when close (like chemical bonds), react to the mouse (attract/repel), and the UI lets you tweak color, particle count, size, and speed. Paste this into molecule.html and open it in your browser.

html
Copy code
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Molecule Particle Playground</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1724;
      --accent: #6ee7b7;
      --muted: rgba(255,255,255,0.08);
      --glass: rgba(255,255,255,0.04);
      --text: #e6eef8;
      --mono: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    }
    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(1200px 800px at 10% 20%, rgba(30,40,60,0.28), transparent),
                  radial-gradient(900px 600px at 90% 80%, rgba(90,60,140,0.08), transparent),
                  var(--bg);
      color:var(--text);
      font-family: var(--mono);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* full-bleed canvas */
    #stage {
      display:block;
      width:100%;
      height:100vh;
      touch-action:none;
    }

    /* top-left title */
    .title {
      position: absolute;
      left: 18px;
      top: 14px;
      z-index: 40;
      display:flex;
      gap:12px;
      align-items:center;
      backdrop-filter: blur(6px) saturate(1.1);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid var(--muted);
      padding:10px 14px;
      border-radius:12px;
      box-shadow: 0 6px 20px rgba(3,6,12,0.55);
    }
    .logo {
      width:38px;
      height:38px;
      border-radius:10px;
      display:grid;
      place-items:center;
      background: linear-gradient(135deg,var(--accent), #8bd3ff 70%);
      box-shadow: 0 6px 14px rgba(110,231,183,0.12), inset 0 -6px 14px rgba(255,255,255,0.06);
      color:#051118;
      font-weight:700;
      font-size:16px;
    }
    .title h1{
      margin:0;
      font-size:14px;
      letter-spacing:0.2px;
    }
    .title p{
      margin:0;
      margin-top:2px;
      font-size:11px;
      color:rgba(230,238,248,0.72);
    }

    /* controls panel */
    .panel {
      position: absolute;
      right: 18px;
      top: 14px;
      width: 300px;
      z-index: 40;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid var(--muted);
      padding:12px;
      border-radius:12px;
      box-shadow: 0 10px 30px rgba(3,6,12,0.55);
      color:var(--text);
      font-size:13px;
    }
    .panel h3{ margin:0 0 10px 0; font-size:13px; }
    .row{ display:flex; align-items:center; gap:10px; margin:8px 0; }
    .row label{ flex:1; font-size:12px; color:rgba(230,238,248,0.86); }
    .row input[type="range"]{ flex:1; }
    .row input[type="color"]{ width:44px; height:34px; padding:0; border-radius:8px; border:0; background:none; }
    .small{ font-size:12px; color:rgba(230,238,248,0.64); }

    .btns{ display:flex; gap:8px; margin-top:10px; }
    .btn{
      flex:1;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:var(--glass);
      color:var(--text);
      font-weight:600;
      cursor:pointer;
      transition:transform .12s ease, box-shadow .12s;
    }
    .btn:active{ transform:translateY(1px) }
    .muted{ opacity:0.9; font-size:12px; color:rgba(230,238,248,0.66) }

    /* footer hint */
    .hint {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 18px;
      z-index:40;
      padding:8px 14px;
      border-radius:999px;
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      font-size:12px;
      color:rgba(230,238,248,0.7);
    }

    @media (max-width:420px){
      .panel{ right:8px; left:8px; width:auto; }
    }
  </style>
</head>
<body>

  <canvas id="stage"></canvas>

  <div class="title" aria-hidden="true">
    <div class="logo">Mo</div>
    <div>
      <h1>Molecule Playground</h1>
      <p class="small">interactive particle bonds ‚Äî move your mouse</p>
    </div>
  </div>

  <div class="panel" role="region" aria-label="controls">
    <h3>Controls</h3>

    <div class="row">
      <label for="count">Particles</label>
      <input id="count" type="range" min="20" max="500" value="120">
    </div>

    <div class="row">
      <label for="size">Particle size</label>
      <input id="size" type="range" min="1" max="6" step="0.5" value="2.2">
    </div>

    <div class="row">
      <label for="speed">Speed</label>
      <input id="speed" type="range" min="0" max="2" step="0.01" value="0.58">
    </div>

    <div class="row">
      <label for="linkRange">Link distance</label>
      <input id="linkRange" type="range" min="20" max="260" value="110">
    </div>

    <div class="row">
      <label>Color</label>
      <input id="color" type="color" value="#6ee7b7">
    </div>

    <div class="row">
      <label for="mode">Mouse mode</label>
      <select id="mode" style="flex:1;padding:6px;border-radius:8px;background:transparent;color:var(--text);border:1px solid rgba(255,255,255,0.04)">
        <option value="attract">Attract</option>
        <option value="repel">Repel</option>
        <option value="none" selected>None</option>
      </select>
    </div>

    <div class="btns">
      <button class="btn" id="randomize">Randomize</button>
      <button class="btn" id="reset">Reset</button>
    </div>

    <div style="margin-top:10px" class="muted">Tip: click/tap to spawn a cluster. Drag to draw trails.</div>
  </div>

  <div class="hint" aria-hidden="true">Click or tap to add a small cluster ‚Ä¢ press space to toggle motion</div>

  <script>
  // Molecule Particle System (single-file, vanilla JS)
  (function(){
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: true });

    // UI elements
    const ui = {
      count: document.getElementById('count'),
      size: document.getElementById('size'),
      speed: document.getElementById('speed'),
      color: document.getElementById('color'),
      linkRange: document.getElementById('linkRange'),
      mode: document.getElementById('mode'),
      randomize: document.getElementById('randomize'),
      reset: document.getElementById('reset'),
    };

    // device pixel ratio for crisp rendering
    let DPR = Math.min(window.devicePixelRatio || 1, 2);

    // state
    let w = 0, h = 0;
    let particles = [];
    let running = true;

    // mouse / touch
    const pointer = { x: null, y: null, down: false };

    // parameters (derived from UI)
    const params = {
      count: parseInt(ui.count.value,10),
      size: parseFloat(ui.size.value),
      speed: parseFloat(ui.speed.value),
      color: ui.color.value,
      linkRange: parseInt(ui.linkRange.value,10),
      mode: ui.mode.value,
    };

    // helpers
    function rand(mn, mx){ return Math.random() * (mx - mn) + mn; }
    function map(v, a, b, c, d){ return c + (v - a) * (d - c) / (b - a); }

    // resize canvas
    function resize(){
      DPR = Math.min(window.devicePixelRatio || 1, 2);
      w = Math.max(300, Math.floor(window.innerWidth));
      h = Math.max(300, Math.floor(window.innerHeight));
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }

    // particle class
    class Particle {
      constructor(x, y){
        this.x = x ?? rand(0, w);
        this.y = y ?? rand(0, h);
        const s = params.size;
        this.r = rand(s * 0.6, s * 1.4);
        this.vx = rand(-0.5, 0.5);
        this.vy = rand(-0.5, 0.5);
        this.mass = this.r * 0.4;
        this.hueShift = rand(-30, 30);
        this.age = 0;
      }
      step(dt){
        // simple Brownian / velocity
        const speed = 0.3 + params.speed * 0.9;
        this.vx += rand(-0.08, 0.08) * speed * 0.5;
        this.vy += rand(-0.08, 0.08) * speed * 0.5;

        // clamp velocity
        const vlim = 2.4 + params.speed * 4.0;
        this.vx = Math.max(-vlim, Math.min(vlim, this.vx));
        this.vy = Math.max(-vlim, Math.min(vlim, this.vy));

        // apply pointer interactions
        if (pointer.x !== null && pointer.y !== null) {
          const dx = pointer.x - this.x;
          const dy = pointer.y - this.y;
          const d2 = dx*dx + dy*dy;
          const d = Math.sqrt(d2) + 0.0001;

          // only influence within a radius
          const influenceRadius = Math.max(80, params.linkRange * 0.8);
          if (d < influenceRadius) {
            const fall = 1 - (d / influenceRadius);
            const force = (params.mode === 'repel' ? -1 : 1) * fall * 0.6 * params.speed;
            this.vx += (dx / d) * force;
            this.vy += (dy / d) * force;

            // slight pull when pointer is down (spawn cluster 'stickiness')
            if (pointer.down) {
              this.vx *= 0.98;
              this.vy *= 0.98;
            }
          }
        }

        // friction / drag
        this.vx *= 0.995;
        this.vy *= 0.995;

        // integrate
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // wrap edges gently
        if (this.x < -20) this.x = w + 20;
        if (this.x > w + 20) this.x = -20;
        if (this.y < -20) this.y = h + 20;
        if (this.y > h + 20) this.y = -20;

        this.age += dt;
      }
      draw(ctx){
        const baseColor = params.color;
        // particle glow
        ctx.beginPath();
        ctx.fillStyle = hexToRGBA(baseColor, 0.12);
        ctx.arc(this.x, this.y, this.r * 6.0, 0, Math.PI*2);
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = hexToRGBA(baseColor, 0.22);
        ctx.arc(this.x, this.y, this.r * 3.0, 0, Math.PI*2);
        ctx.fill();

        // core
        ctx.beginPath();
        ctx.fillStyle = hexToRGBA(baseColor, 1.0);
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // color helpers
    function hexToRGBA(hex, alpha=1){
      // support formats: #RRGGBB or #RGB
      if (!hex) return `rgba(110,231,183,${alpha})`;
      const h = hex.replace('#','');
      let r,g,b;
      if (h.length === 3){
        r = parseInt(h[0]+h[0],16);
        g = parseInt(h[1]+h[1],16);
        b = parseInt(h[2]+h[2],16);
      } else {
        r = parseInt(h.slice(0,2),16);
        g = parseInt(h.slice(2,4),16);
        b = parseInt(h.slice(4,6),16);
      }
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // build particle array
    function buildParticles(n){
      particles.length = 0;
      for (let i=0;i<n;i++){
        particles.push(new Particle());
      }
    }

    // draw bonds (lines) between nearby particles
    function drawLinks(ctx){
      const linkMax = params.linkRange;
      const len = particles.length;
      for (let i=0;i<len;i++){
        const A = particles[i];
        for (let j=i+1;j<len;j++){
          const B = particles[j];
          const dx = A.x - B.x;
          const dy = A.y - B.y;
          const d2 = dx*dx + dy*dy;
          if (d2 > linkMax * linkMax) continue;
          const d = Math.sqrt(d2);
          const t = 1 - (d / linkMax);
          // bonding force (mild)
          const bond = t * 0.0008 * params.speed;
          A.vx += (dx / d) * bond * -1;
          A.vy += (dy / d) * bond * -1;
          B.vx += (dx / d) * bond;
          B.vy += (dy / d) * bond;

          // draw line
          ctx.beginPath();
          ctx.moveTo(A.x, A.y);
          ctx.lineTo(B.x, B.y);
          ctx.lineWidth = Math.max(0.3, t * 1.6);
          ctx.strokeStyle = hexToRGBA(params.color, Math.max(0.05, t * 0.45));
          ctx.stroke();
        }
      }
    }

    // animation loop
    let last = performance.now();
    function loop(t){
      if (!running) {
        last = t;
        requestAnimationFrame(loop);
        return;
      }
      const dtRaw = (t - last) / (1000/60); // normalize to 60fps base
      const dt = Math.min(3, dtRaw); // clamp big deltas
      last = t;

      // clear with small alpha to make subtle trails
      ctx.clearRect(0,0,w,h);
      ctx.globalCompositeOperation = 'lighter';

      // subtle vignette background
      ctx.fillStyle = 'rgba(6,8,16,0.16)';
      ctx.fillRect(0,0,w,h);

      // links
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      drawLinks(ctx);
      ctx.restore();

      // particles
      for (let i=0;i<particles.length;i++){
        particles[i].step(dt);
      }
      for (let i=0;i<particles.length;i++){
        particles[i].draw(ctx);
      }

      // pointer indicator
      if (pointer.x !== null && pointer.y !== null){
        ctx.beginPath();
        ctx.arc(pointer.x, pointer.y, 8, 0, Math.PI*2);
        ctx.fillStyle = hexToRGBA(params.color, 0.08);
        ctx.fill();
      }

      requestAnimationFrame(loop);
    }

    // events
    function onPointerMove(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX || (e.touches && e.touches[0].clientX) || 0) - rect.left;
      const y = (e.clientY || (e.touches && e.touches[0].clientY) || 0) - rect.top;
      pointer.x = x;
      pointer.y = y;
    }
    function onPointerDown(e){
      pointer.down = true;
      onPointerMove(e);
      spawnCluster(pointer.x, pointer.y, 6);
    }
    function onPointerUp(){
      pointer.down = false;
    }
    function onLeave(){
      // don't null out on leave on mobile; keep for desktop
      pointer.x = null;
      pointer.y = null;
    }

    // spawn a small cluster of particles at x,y
    function spawnCluster(x,y, n=8){
      for (let i=0;i<n;i++){
        const p = new Particle(x + rand(-16,16), y + rand(-16,16));
        p.vx += rand(-1.6,1.6);
        p.vy += rand(-1.6,1.6);
        particles.push(p);
      }
      // clamp to max preferred
      capParticles();
    }

    // keep particle list sensible
    function capParticles(){
      const max = Math.max(20, parseInt(ui.count.max));
      const desired = parseInt(ui.count.value,10);
      if (particles.length > desired){
        particles.splice(0, particles.length - desired);
      }
    }

    // wire UI controls
    ui.count.addEventListener('input', (e) => {
      params.count = parseInt(e.target.value,10);
      // grow or shrink to target
      const target = params.count;
      if (particles.length < target){
        const add = target - particles.length;
        for (let i=0;i<add;i++) particles.push(new Particle());
      } else if (particles.length > target){
        particles.splice(0, particles.length - target);
      }
    });
    ui.size.addEventListener('input', (e) => {
      params.size = parseFloat(e.target.value);
      // apply to particles (new sizes will appear slowly)
      for (let p of particles) p.r = rand(params.size * 0.6, params.size * 1.4);
    });
    ui.speed.addEventListener('input', (e) => { params.speed = parseFloat(e.target.value); });
    ui.color.addEventListener('input', (e) => { params.color = e.target.value; });
    ui.linkRange.addEventListener('input', (e) => { params.linkRange = parseInt(e.target.value,10); });
    ui.mode.addEventListener('change', (e) => { params.mode = e.target.value; });

    ui.randomize.addEventListener('click', () => {
      // random palette & small shuffle
      const palette = ['#6ee7b7','#8bd3ff','#ffd27e','#ff90c1','#cdb4ff','#9ce3ff'];
      params.color = palette[Math.floor(rand(0, palette.length))];
      ui.color.value = params.color;
      // random speed
      params.speed = parseFloat(map(Math.random(),0,1,0.08,1.4).toFixed(2));
      ui.speed.value = params.speed;
      // random count
      const c = Math.floor(rand(40, 320));
      ui.count.value = c; ui.count.dispatchEvent(new Event('input'));
    });

    ui.reset.addEventListener('click', () => {
      // restore defaults
      ui.count.value = 120; ui.count.dispatchEvent(new Event('input'));
      ui.size.value = 2.2; ui.size.dispatchEvent(new Event('input'));
      ui.speed.value = 0.58; ui.speed.dispatchEvent(new Event('input'));
      ui.linkRange.value = 110; ui.linkRange.dispatchEvent(new Event('input'));
      ui.color.value = '#6ee7b7'; ui.color.dispatchEvent(new Event('input'));
      ui.mode.value = 'none'; ui.mode.dispatchEvent(new Event('change'));
    });

    // keyboard: space to pause
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        running = !running;
      }
      // quick shortcuts
      if (e.key === 'r') ui.randomize.click();
      if (e.key === 'c') ui.color.focus();
    });

    // pointer events
    canvas.addEventListener('mousemove', onPointerMove);
    canvas.addEventListener('touchmove', onPointerMove, { passive:true });
    canvas.addEventListener('mousedown', onPointerDown);
    canvas.addEventListener('touchstart', onPointerDown, { passive:true });
    window.addEventListener('mouseup', onPointerUp);
    window.addEventListener('touchend', onPointerUp);
    canvas.addEventListener('mouseleave', onLeave);

    // handle visibility change to stop ticks
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) running = false;
      else running = true;
    });

    // initialization
    function init(){
      resize();
      buildParticles(params.count);
      last = performance.now();
      requestAnimationFrame(loop);
    }

    // listen for resize
    window.addEventListener('resize', () => {
      resize();
    });

    // small performance guard: if many particles, reduce glow draws
    // but keep visual style.

    // expose some debug for console
    window.__molecule = {
      particles,
      params,
      spawn: spawnCluster,
    };

    // start
    init();

  })();
  </script>
</body>
</html>